import { RequestContext } from '@av/common'
import { EntityType, PrismaService } from '@av/database'
import {
  LocalizationSettingsService,
  TranslateProviderFactory,
  UpsertTranslationInput,
  TranslationPersistenceService,
} from '@av/localize'
import { TranslationProvider as GqlTranslationProvider } from '@av/localize'

import { Injectable } from '@nestjs/common'

@Injectable()
export class SegmentService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly translateProviderFactory: TranslateProviderFactory,
    private readonly localizationSettingsService: LocalizationSettingsService,
    private readonly translationService: TranslationPersistenceService,
  ) {}

  async createSegment(
    ctx: RequestContext,
    data: { name: string; path: string },
  ) {
    const translationProvider = await this.translateProviderFactory.getProvider(
      ctx,
      'GOOGLE_TRANSLATE',
    )
    const settings =
      await this.localizationSettingsService.getLocalizationSettings(ctx)
    const translationProviderName = settings?.translationProvider

    const segment = await this.prisma.segment.create({
      data: {
        ...data,
        channel_token: ctx.channel.token,
      },
    })

    if (!settings.enabled && !settings.dynamicSegmentsEnabled) {
      return { segment }
    }

    const locales = await this.prisma.locales.findMany({
      where: { isActive: true, channel_token: ctx.channel.token },
    })

    const translations: UpsertTranslationInput[] = await Promise.all(
      locales.map(async (locale) => {
        const translatedValue = await translationProvider.translate(
          ctx,
          data.name,
          ctx.channel.defaultLanguageCode,
          locale.code,
        )

        return {
          entityType: EntityType.SEGMENT,
          entityId: segment.id.toString(),
          fields: {
            name: translatedValue as string,
          },
          translationProvider:
            translationProviderName as GqlTranslationProvider,
          autoGenerated: true,
          locale: locale.code,
          lastSyncedAt: new Date(),
        }
      }),
    )

    const savedTranslations = await Promise.all(
      translations.map((translation) =>
        this.translationService.upsertTranslations(ctx, translation),
      ),
    )

    return { segment, translations: savedTranslations }
  }

  async getSegmentsWithTranslations(ctx: RequestContext) {
    const segments = await this.prisma.segment.findMany({
      where: { channel_token: ctx.channel.token },
    })

    const settings = ctx.localizationSettings

    if (!settings.enabled && !settings.dynamicSegmentsEnabled) {
      return segments
    }

    return await Promise.all(
      segments.map((segment) => ({
        segment,
        translations: this.translationService.getTranslationsOfEntity(
          ctx,
          EntityType.SEGMENT,
          segment.id.toString(),
        ),
      })),
    )
  }

  async getLocalizedSegmentByPath(ctx: RequestContext, path: string) {
    const segment = await this.prisma.segment.findFirst({
      where: { channel_token: ctx.channel.token, path },
    })

    const settings = ctx.localizationSettings

    if (settings.enabled && settings.dynamicSegmentsEnabled) {
      const translatedSegment =
        await this.translationService.mergeEntityWithTranslation(
          ctx,
          { ...segment, id: segment.id.toString() },
          EntityType.SEGMENT,
        )

      return translatedSegment
    }

    return segment
  }

  async getSegmentByPath(ctx: RequestContext, path: string) {
    const segment = await this.prisma.segment.findFirst({
      where: { channel_token: ctx.channel.token, path },
    })

    // get segment translations
    const translations = await this.translationService.getTranslationsOfEntity(
      ctx,
      EntityType.SEGMENT,
      segment.id.toString(),
    )

    return { segment, translations }
  }

  async getMany(ctx: RequestContext) {
    const segments = await this.prisma.segment.findMany({
      where: { channel_token: ctx.channel.token },
    })

    return segments
  }
}
