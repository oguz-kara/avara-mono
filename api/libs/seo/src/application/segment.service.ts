import { RequestContext } from '@av/common'
import { EntityType, PrismaService } from '@av/database'
import {
  LocalizationSettingsService,
  TranslateProviderFactory,
  UpsertTranslationInput,
} from '@av/localize'
import { TranslationPersistenceService } from '@av/localize/application/translation-persistence.service'
import { TranslationProvider as GqlTranslationProvider } from '@av/localize/api/graphql/enum'

import { Injectable } from '@nestjs/common'

@Injectable()
export class SegmentService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly translateProviderFactory: TranslateProviderFactory,
    private readonly localizationSettingsService: LocalizationSettingsService,
    private readonly translationService: TranslationPersistenceService,
  ) {}

  async createSegment(
    ctx: RequestContext,
    data: { name: string; path: string },
  ) {
    const translationProvider = await this.translateProviderFactory.getProvider(
      ctx,
      undefined,
    )
    const settings =
      await this.localizationSettingsService.getLocalizationSettings(ctx)
    const translationProviderName = settings?.translationProvider

    const segment = await this.prisma.segment.create({
      data: {
        ...data,
        channel_token: ctx.channel.token,
      },
    })

    // 2) Fetch all active locales
    const locales = await this.prisma.locales.findMany({
      where: { isActive: true, channel_token: ctx.channel.token },
    })

    const translations: UpsertTranslationInput[] = await Promise.all(
      locales.map(async (locale) => {
        const translatedValue = await translationProvider.translate(
          ctx,
          data.name,
          ctx.channel.defaultLanguageCode,
          locale.code,
        )

        return {
          entityType: EntityType.SEGMENT,
          entityId: segment.id.toString(),
          fields: {
            name: translatedValue as string,
          },
          translationProvider:
            translationProviderName as GqlTranslationProvider,
          autoGenerated: true,
          locale: locale.code,
          lastSyncedAt: new Date(),
        }
      }),
    )

    const savedTranslations = await Promise.all(
      translations.map((translation) =>
        this.translationService.upsertTranslations(ctx, translation),
      ),
    )

    return { segment, translations: savedTranslations }
  }

  async getSegmentsWithTranslations(ctx: RequestContext) {
    const segments = await this.prisma.segment.findMany({
      where: { channel_token: ctx.channel.token },
    })

    return await Promise.all(
      segments.map((segment) => ({
        segment,
        translations: this.translationService.getTranslations(
          ctx,
          EntityType.SEGMENT,
          segment.id.toString(),
        ),
      })),
    )
  }
}
