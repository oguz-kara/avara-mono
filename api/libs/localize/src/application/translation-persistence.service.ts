import { Injectable } from '@nestjs/common'

import { RequestContext } from '@av/common'
import { EntityType, PrismaService, Translation } from '@av/database'

import { UpsertTranslationInput } from '../api/graphql/dto'

interface DeleteTranslationsInput {
  entityType: EntityType
  entityIds: string[]
}

interface DeleteTranslationInput {
  entityType: EntityType
  entityId: string
}

@Injectable()
export class TranslationPersistenceService {
  constructor(private readonly prisma: PrismaService) {}

  async getTranslation<T = Record<string, string>>(
    ctx: RequestContext,
    entityType: EntityType,
    entityId: string,
    locale: string,
  ): Promise<T> {
    const translation = await this.prisma.translation.findMany({
      where: {
        entityType,
        entityId,
        locale,
        channel_token: ctx.channel.token,
      },
    })

    return this.parseToObject(translation) as T
  }

  async getTranslations<T = Record<string, string>>(
    ctx: RequestContext,
    entityType: EntityType,
    entityId: string,
  ): Promise<T[]> {
    const langs = await this.prisma.locales.findMany({
      where: { channel_token: ctx.channel.token },
    })

    const translations = await Promise.all(
      langs.map((lang) =>
        this.getTranslation(ctx, entityType, entityId, lang.code),
      ),
    )

    return translations as T[]
  }

  async upsertTranslations(ctx: RequestContext, input: UpsertTranslationInput) {
    const operations = Object.entries(input.fields).map(
      ([fieldName, translatedValue]) =>
        this.prisma.translation.upsert({
          where: {
            entityType_entityId_locale_fieldName: {
              entityType: input.entityType as EntityType,
              entityId: input.entityId,
              locale: input.locale,
              fieldName,
            },
          },
          update: {
            translatedValue,
            lastSyncedAt: new Date(),
            ...(input.autoGenerated && { autoGenerated: input.autoGenerated }),
          },
          create: {
            entityType: input.entityType as EntityType,
            entityId: input.entityId,
            locale: input.locale,
            fieldName,
            translatedValue,
            autoGenerated: input.autoGenerated || false,
            lastSyncedAt: new Date(),
            channel_token: ctx.channel.token,
          },
        }),
    )

    const translations = await Promise.all(operations)

    return { fields: this.parseToObject(translations) }
  }

  async deleteTranslations(
    ctx: RequestContext,
    input: DeleteTranslationsInput,
  ) {
    const translations = await this.prisma.translation.deleteMany({
      where: {
        entityType: input.entityType,
        entityId: { in: input.entityIds },
        channel_token: ctx.channel.token,
      },
    })

    return translations
  }

  async deleteTranslation(ctx: RequestContext, input: DeleteTranslationInput) {
    const translations = await this.prisma.translation.deleteMany({
      where: {
        entityType: input.entityType,
        entityId: input.entityId,
        channel_token: ctx.channel.token,
      },
    })

    return translations
  }

  private parseToObject(translations: Translation[]) {
    return translations.reduce(
      (result, { fieldName, translatedValue }) => ({
        ...result,
        [fieldName]: translatedValue,
      }),
      {},
    )
  }
}
