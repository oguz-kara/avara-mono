import { Injectable } from '@nestjs/common'
import { OnEvent } from '@nestjs/event-emitter'
<<<<<<< HEAD
=======

>>>>>>> integrate-keycloak
import {
  EVENT_LIST,
  TranslateableEntityCreatedEvent,
  TranslateableEntityDeletedEvent,
  TranslateableEntityDeletedMultipleEvent,
  TranslateableEntityUpdatedEvent,
} from '@av/common'
<<<<<<< HEAD
import { TranslateAIService } from '../translate-ai.service'
import { PrismaService } from '@av/database'
import { TranslationPersistenceService } from '../translation-persistence.service'
import { ChannelService } from '@av/channel'
=======

import { TranslationOrchestratorService } from '../services/translation-orchestrator.service'
import { LocalizationSettingsService } from '../services/localization-settings.service'
import { TranslateableEntityCreatedMultipleEvent } from '@av/common/events/translateable-entity-created-multiple.event'
import { TranslateableEntityUpdatedMultipleEvent } from '@av/common/events/translateable-entity-updated-multiple.event'
>>>>>>> integrate-keycloak

@Injectable()
export class TranslatableEntityListener {
  constructor(
    private readonly translationOrchestratorService: TranslationOrchestratorService,
    private readonly localizationSettingsService: LocalizationSettingsService,
  ) {}

  @OnEvent(EVENT_LIST.TRANSLATEABLE_ENTITY_CREATED)
  async handleTranslateableEntityCreatedEvent(
    event: TranslateableEntityCreatedEvent,
  ) {
    if (await this.isLocalizationEnabled(event)) {
      return this.translationOrchestratorService.handleEntityCreatedEvent(event)
    }
  }

  @OnEvent(EVENT_LIST.TRANSLATEABLE_ENTITY_UPDATED)
  async handleTranslateableEntityUpdatedEvent(
    event: TranslateableEntityUpdatedEvent,
  ) {
    if (await this.isLocalizationEnabled(event)) {
      return this.translationOrchestratorService.handleEntityUpdatedEvent(event)
    }
  }

<<<<<<< HEAD
    if (!entityId) {
      this.logger.debug(`Entity ID is required for translation`, {
        channel: ctx.channel.token,
        entityType,
        entityId,
      })
      return
    }

    if (!entityType) {
      this.logger.debug(`Entity type is required for translation`, {
        channel: ctx.channel.token,
        entityType,
        entityId,
      })
      return
    }

    const fieldsToTranslate = Object.entries(fields)
      .filter((entry) => Boolean(entry[1]))
      .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {})

    if (Object.keys(fieldsToTranslate).length === 0) {
      this.logger.debug(`No fields to translate for entity ${entityId}`, {
        channel: ctx.channel.token,
        entityType,
        entityId,
      })
      return
    }

    const channel = await this.channelService.getChannelByToken(
      ctx,
      ctx.channel.token,
      {
        channelSettings: true,
      },
    )

    const autoTranslate = channel.channelSettings?.autoTranslate || true

    if (!autoTranslate) {
      this.logger.debug(
        `Auto translate is disabled for channel ${channel.token}`,
=======
  @OnEvent(EVENT_LIST.TRANSLATEABLE_ENTITY_DELETED)
  async handleTranslateableEntityDeletedEvent(
    event: TranslateableEntityDeletedEvent,
  ) {
    if (await this.isLocalizationEnabled(event)) {
      return this.translationOrchestratorService.handleEntityDeletedEvent(event)
    }
  }

  @OnEvent(EVENT_LIST.TRANSLATEABLE_ENTITY_DELETED_MULTIPLE)
  async handleTranslateableEntityDeletedMultipleEvent(
    event: TranslateableEntityDeletedMultipleEvent,
  ) {
    if (await this.isLocalizationEnabled(event)) {
      console.log('event emitted')
      return this.translationOrchestratorService.handleEntityDeletedMultipleEvent(
        event,
>>>>>>> integrate-keycloak
      )
    }
  }

<<<<<<< HEAD
    const langs = await this.prisma.locales.findMany({
      where: {
        channel_token: channel.token,
      },
    })

    const translations = await Promise.all(
      langs.map(async (lang) => {
        this.logger.debug(
          `Updating translation of fields ${JSON.stringify(fieldsToTranslate)} from ${ctx.channel.defaultLanguageCode} to ${lang.code}`,
        )
        const translatedContent = await this.translateAiService.translate(
          JSON.stringify(fieldsToTranslate),
          ctx.channel.defaultLanguageCode,
          lang.code,
        )

        this.logger.debug(
          `Updated translation fields ${JSON.stringify(translatedContent)} to ${lang.code}`,
        )

        const updatedTranslation =
          await this.translationPersistenceService.upsertTranslations(ctx, {
            entityType: entityType,
            entityId: entityId.toString(),
            locale: lang.code,
            fields: translatedContent as Record<string, string>,
            autoGenerated: true,
          })

        this.logger.debug(
          `Updated translation ${JSON.stringify(updatedTranslation)}`,
        )

        return updatedTranslation
      }),
=======
  @OnEvent(EVENT_LIST.TRANSLATEABLE_ENTITY_CREATED_MULTIPLE)
  async handleTranslateableEntityCreatedMultipleEvent(
    event: TranslateableEntityCreatedMultipleEvent,
  ) {
    return this.translationOrchestratorService.handleEntityCreatedMultipleEvent(
      event,
>>>>>>> integrate-keycloak
    )
  }

  @OnEvent(EVENT_LIST.TRANSLATEABLE_ENTITY_UPDATED_MULTIPLE)
  async handleTranslateableEntityUpdatedMultipleEvent(
    event: TranslateableEntityUpdatedMultipleEvent,
  ) {
    return this.translationOrchestratorService.handleEntityUpdatedMultipleEvent(
      event,
    )
  }

  private async isLocalizationEnabled(event: any): Promise<boolean> {
    console.log('event', event)
    if (!event.ctx?.channel?.token) {
      return false
    }

    return await this.localizationSettingsService.isAutoTranslateEnabled(
      event.ctx,
    )
  }

  @OnEvent(EVENT_LIST.TRANSLATEABLE_ENTITY_DELETED_MULTIPLE)
  async handleTranslateableEntityDeletedMultipleEvent(
    event: TranslateableEntityDeletedMultipleEvent,
  ) {
    const { entityIds, entityType, ctx } = event

    if (!entityIds || !entityType) {
      this.logger.debug(
        `Entity ID and type are required for translation deletion`,
        {
          channel: ctx.channel.token,
          entityType,
          entityIds,
        },
      )
      return
    }

    this.logger.debug(
      `Deleting translations for entity ${entityType} with IDs ${entityIds}`,
      {
        channel: ctx.channel.token,
        entityType,
        entityIds,
      },
    )

    const translations =
      await this.translationPersistenceService.deleteTranslations(ctx, {
        entityType: entityType,
        entityIds: entityIds,
      })

    this.logger.debug(`Deleted translations`, {
      channel: ctx.channel.token,
      entityType,
      entityIds,
      translations,
    })
  }

  @OnEvent(EVENT_LIST.TRANSLATEABLE_ENTITY_DELETED)
  async handleTranslateableEntityDeletedEvent(
    event: TranslateableEntityDeletedEvent,
  ) {
    const { entityId, entityType, ctx } = event

    this.logger.debug(
      `Deleting translations for entity ${entityType} with ID ${entityId}`,
      {
        channel: ctx.channel.token,
        entityType,
        entityId,
      },
    )

    const translations =
      await this.translationPersistenceService.deleteTranslation(ctx, {
        entityType: entityType,
        entityId: entityId,
      })

    this.logger.debug(`Deleted translations`, {
      channel: ctx.channel.token,
      entityType,
      entityId,
      translations,
    })
  }
}
