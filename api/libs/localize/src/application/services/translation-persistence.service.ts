import { Injectable } from '@nestjs/common'

import { RequestContext } from '@av/common'
import { EntityType, PrismaService, Translation } from '@av/database'
import { UpsertTranslationInput } from '@av/localize'
import { TranslationProvider as GqlTranslationProvider } from '@av/localize'
import { LocalesService } from './locales.service'
import { ProductTranslation } from '../types'

@Injectable()
export class TranslationPersistenceService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly localesService: LocalesService,
  ) {}

  async getTranslation<T = Record<string, string>>(
    ctx: RequestContext,
    entityType: EntityType,
    entityId: string,
    locale: string,
  ): Promise<T | null> {
    const hasLocale = await this.localesService.hasLocale(ctx, locale)
    if (!hasLocale) {
      locale = ctx.channel.defaultLanguageCode
    }

    const translation = await this.prisma.translation.findMany({
      where: {
        entityType,
        entityId,
        locale,
        channel_token: ctx.channel.token,
      },
    })

    return { ...this.parseToObject(translation), locale } as T
  }

  async getEntityIdBySlugTranslation(
    ctx: RequestContext,
    entityType: EntityType,
    slug: string,
    locale: string,
  ): Promise<string | null> {
    const hasLocale = await this.localesService.hasLocale(ctx, locale)

    if (!hasLocale) {
      locale = ctx.channel.defaultLanguageCode
    }

    console.log({ locale })

    const slugTranslation = await this.prisma.translation.findFirst({
      where: {
        entityType,
        fieldName: 'slug',
        translatedValue: slug,
        locale,
        channel_token: ctx.channel.token,
      },
    })

    if (!slugTranslation) {
      return null
    }

    return slugTranslation['entityId']
  }

  async getTranslationsOfEntity<T = Record<string, string>>(
    ctx: RequestContext,
    entityType: EntityType,
    entityId: string,
  ): Promise<T[]> {
    const langs = await this.prisma.locales.findMany({
      where: { channel_token: ctx.channel.token },
    })

    const translations = await Promise.all(
      langs.map((lang) =>
        this.getTranslation(ctx, entityType, entityId, lang.code),
      ),
    )

    return translations as T[]
  }

  async upsertTranslations(ctx: RequestContext, input: UpsertTranslationInput) {
    const settings = ctx.localizationSettings

    const operations = Object.entries(input.fields).map(
      ([fieldName, translatedValue]) =>
        this.prisma.translation.upsert({
          where: {
            entityType_entityId_locale_fieldName: {
              entityType: input.entityType as EntityType,
              entityId: input.entityId,
              locale: input.locale,
              fieldName,
            },
          },
          update: {
            translatedValue,
            lastSyncedAt: new Date(),
            ...(input.autoGenerated && { autoGenerated: input.autoGenerated }),
          },
          create: {
            entityType: input.entityType as EntityType,
            entityId: input.entityId,
            locale: input.locale,
            fieldName,
            translatedValue,
            autoGenerated: input.autoGenerated || false,
            lastSyncedAt: new Date(),
            channel_token: ctx.channel.token,
            translatorModel:
              settings.translationProvider as GqlTranslationProvider,
          },
        }),
    )

    const translations = await Promise.all(operations)

    return { fields: this.parseToObject(translations) }
  }

  async deleteTranslations(
    ctx: RequestContext,
    entityType: EntityType,
    entityIds: string[],
  ) {
    await this.prisma.translation.deleteMany({
      where: {
        entityType,
        entityId: {
          in: entityIds,
        },
        channel_token: ctx.channel.token,
      },
    })
  }

  async getTranslations(
    ctx: RequestContext,
    entityIds: string[],
    entityType: EntityType,
  ): Promise<Translation[]> {
    const translations = await this.prisma.translation.findMany({
      where: {
        entityId: { in: entityIds },
        locale: ctx.languageCode,
        entityType,
        channel_token: ctx.channel.token,
      },
      select: {
        entityId: true,
        fieldName: true,
        translatedValue: true,
      },
    })

    return translations as Translation[]
  }

  async getTranslationByEntityId(
    ctx: RequestContext,
    entityId: string,
    entityType: EntityType,
  ): Promise<ProductTranslation | null> {
    const translation = await this.getTranslation(
      ctx,
      entityType,
      entityId,
      ctx.languageCode,
    )

    if (!translation) {
      return null
    }

    return translation as ProductTranslation
  }

  async getTranslationsByEntityId(
    ctx: RequestContext,
    entityId: string,
    entityType: EntityType,
  ): Promise<ProductTranslation[]> {
    return this.getTranslationsOfEntity(ctx, entityType, entityId)
  }

  async mergeEntityWithTranslation<Entity extends { id: string }>(
    ctx: RequestContext,
    entity: Entity | Entity[],
    entityType: EntityType,
    relations?: Record<string, boolean | object>,
  ): Promise<Entity | Entity[]> {
    if (Array.isArray(entity)) {
      return (await Promise.all(
        entity.map((item) =>
          this.mergeEntityWithTranslation(ctx, item, entityType, relations),
        ),
      )) as Entity[]
    }

    if (ctx.isDefaultLanguage) {
      return entity
    }

    if (!this.mapEntityKeyToType(entityType, entityType)) {
      return entity
    }

    const entityTranslation = entity?.id
      ? await this.getTranslationByEntityId(ctx, entity.id, entityType)
      : null

    if (!entityTranslation) {
      return entity
    }

    const entityData = relations
      ? Object.fromEntries(
          Object.entries(entity).filter(([key]) => !(key in relations)),
        )
      : entity

    const relationsData = relations
      ? Object.entries(entity).filter(([key]) => key in relations)
      : []

    const translatedRelations = await this.translateRelations(
      ctx,
      relationsData,
      entityType,
      relations,
    )

    return {
      ...entityData,
      ...entityTranslation,
      ...translatedRelations,
    } as Entity
  }

  async translationFieldExists(
    ctx: RequestContext,
    entityId: string,
    entityType: EntityType,
    fieldName: string,
    locale: string,
  ) {
    const translation = await this.prisma.translation.findFirst({
      where: {
        entityType,
        entityId,
        fieldName,
        locale,
        channel_token: ctx.channel.token,
      },
    })

    return !!translation
  }

  async mergeEntityListWithTranslation<Entity extends { id: string }>(
    ctx: RequestContext,
    entityOrEntities: Entity | Entity[],
    entityType: EntityType,
    relations?: Record<string, boolean | object>,
  ): Promise<Entity | Entity[]> {
    return this.mergeEntityWithTranslation(
      ctx,
      entityOrEntities,
      entityType,
      relations,
    )
  }

  private async translateRelations(
    ctx: RequestContext,
    relationsData: [string, any][],
    entityType: EntityType,
    relations?: Record<string, boolean | object>,
  ): Promise<Record<string, any>> {
    if (!relationsData.length) {
      return {}
    }

    const translations = await Promise.all(
      relationsData.map(async ([key, relation]) => {
        const relationType = this.mapEntityKeyToType(key, entityType)
        if (!relationType) {
          return [key, relation]
        }

        const nestedRelations =
          typeof relations?.[key] === 'object'
            ? (relations[key] as object)
            : undefined

        const translatedRelation = await this.mergeEntityWithTranslation(
          ctx,
          relation,
          relationType,
          nestedRelations as any,
        )

        return [key, translatedRelation]
      }),
    )

    return Object.fromEntries(translations)
  }

  private parseToObject(translations: Translation[]) {
    return translations.reduce(
      (result, { fieldName, translatedValue }) => ({
        ...result,
        [fieldName]: translatedValue,
      }),
      {},
    )
  }

  private mapEntityKeyToType(
    key: string,
    entityType: EntityType,
  ): EntityType | undefined {
    console.log({ entityType })
    switch (key.toLowerCase()) {
      case 'seo_metadata':
        return EntityType.SEO_METADATA
      case 'seometadata':
        return EntityType.SEO_METADATA
      case 'collection':
        return EntityType.COLLECTION
      case 'facet':
        return EntityType.FACET
      case 'facetvalue':
        return EntityType.FACET_VALUE
      case 'values':
        return EntityType.FACET_VALUE
      case 'facet_value':
        return EntityType.FACET_VALUE
      case 'product':
        return EntityType.PRODUCT
      case 'segment':
        return EntityType.SEGMENT

      default:
        return undefined
    }
  }
}
