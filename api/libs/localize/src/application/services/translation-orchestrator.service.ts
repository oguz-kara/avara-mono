import { PrismaService } from '@av/database'
import { Injectable, Logger } from '@nestjs/common'
import { TranslationPersistenceService } from './translation-persistence.service'
import { ChannelService } from '@av/channel'
import { RequestContext, TranslateableEntityCreatedEvent } from '@av/common'
import {
  TranslateableEntityDeletedEvent,
  TranslateableEntityDeletedMultipleEvent,
  TranslateableEntityUpdatedEvent,
} from '@av/common/events'
import { TranslateProviderFactory } from '@av/localize/infrastructure/factories/translate-provider.factory'
import { TranslationProvider as GqlTranslationProvider } from '@av/localize'
import { ConfigService } from '@nestjs/config'
import { TranslateableEntityCreatedMultipleEvent } from '@av/common/events/translateable-entity-created-multiple.event'
import { TranslateableEntityUpdatedMultipleEvent } from '@av/common/events/translateable-entity-updated-multiple.event'

@Injectable()
export class TranslationOrchestratorService {
  private readonly logger = new Logger(TranslationOrchestratorService.name)
  private readonly autoTranslateSlugify: string

  constructor(
    private readonly prisma: PrismaService,
    private readonly translateProviderFactory: TranslateProviderFactory,
    private readonly translationPersistenceService: TranslationPersistenceService,
    private readonly channelService: ChannelService,
    private readonly configService: ConfigService,
  ) {
    this.autoTranslateSlugify = this.configService.get(
      'localization.autoTranslate.slugify',
    )
  }

  async handleEntityCreatedEvent(event: TranslateableEntityCreatedEvent) {
    const { entityId, entityType, fields, ctx } = event

    const localizeSettings = ctx.localizationSettings

    const channel = await this.channelService.getChannelByToken(
      ctx.channel.token,
    )

    const autoTranslate = localizeSettings.autoTranslate || true

    if (!autoTranslate) {
      this.logger.debug(
        `Auto translate is disabled for channel ${channel.token}`,
      )

      this.logger.debug(`Aborting listener...`, {
        channel: channel.token,
        entityType,
        entityId,
      })
      return
    }

    const langs = await this.prisma.locales.findMany({
      where: {
        channel_token: channel.token,
      },
    })

    const translations = await Promise.all(
      langs.map(async (lang) => {
        this.logger.debug(
          `Translating fields ${JSON.stringify(fields)} from ${ctx.channel.defaultLanguageCode} to ${lang.code}`,
        )
        const translatedContent = await this.translateFields(
          ctx,
          fields,
          ctx.channel.defaultLanguageCode,
          lang.code,
        )

        this.slugifySlugField(translatedContent)

        this.logger.debug(
          `Translated fields ${JSON.stringify(translatedContent)} to ${lang.code}`,
        )

        const createdTranslation =
          await this.translationPersistenceService.upsertTranslations(ctx, {
            entityType: entityType,
            entityId: entityId.toString(),
            locale: lang.code,
            fields: translatedContent as Record<string, string>,
            autoGenerated: true,
            lastSyncedAt: new Date(),
            translationProvider:
              localizeSettings.translationProvider as GqlTranslationProvider,
          })

        this.logger.debug(
          `Created translation ${JSON.stringify(createdTranslation)}`,
        )

        return createdTranslation
      }),
    )

    return translations
  }

  async handleEntityUpdatedEvent(event: TranslateableEntityUpdatedEvent) {
    const { entityId, entityType, fields, ctx } = event

    const settings = ctx.localizationSettings

    const channel = await this.channelService.getChannelByToken(
      ctx.channel.token,
    )

    const autoTranslate = settings.autoTranslate || true

    if (!autoTranslate) {
      this.logger.debug(
        `Auto translate is disabled for channel ${channel.token}`,
      )

      this.logger.debug(`Aborting listener...`, {
        channel: channel.token,
        entityType,
        entityId,
      })
      return
    }

    const langs = await this.prisma.locales.findMany({
      where: {
        channel_token: channel.token,
      },
    })

    const translations = await Promise.all(
      langs.map(async (lang) => {
        this.logger.debug(
          `Updating translation of fields ${JSON.stringify(fields)} from ${ctx.channel.defaultLanguageCode} to ${lang.code}`,
        )
        const translatedContent = await this.translateFields(
          ctx,
          fields,
          ctx.channel.defaultLanguageCode,
          lang.code,
        )

        this.logger.debug(
          `Updated translation fields ${JSON.stringify(translatedContent)} to ${lang.code}`,
        )

        this.slugifySlugField(translatedContent)

        const updatedTranslation =
          await this.translationPersistenceService.upsertTranslations(ctx, {
            entityType: entityType,
            entityId: entityId.toString(),
            locale: lang.code,
            fields: translatedContent as Record<string, string>,
            autoGenerated: true,
            lastSyncedAt: new Date(),
            translationProvider:
              settings.translationProvider as GqlTranslationProvider,
          })

        this.logger.debug(
          `Updated translation ${JSON.stringify(updatedTranslation)}`,
        )

        return updatedTranslation
      }),
    )

    return translations
  }

  async handleEntityDeletedEvent(event: TranslateableEntityDeletedEvent) {
    const { entityId, entityType, ctx } = event

    await this.translationPersistenceService.deleteTranslations(
      ctx,
      entityType,
      [entityId.toString()],
    )
  }

  async handleEntityDeletedMultipleEvent(
    event: TranslateableEntityDeletedMultipleEvent,
  ) {
    const { entityIds, entityType, ctx } = event

    await this.translationPersistenceService.deleteTranslations(
      ctx,
      entityType,
      entityIds,
    )
  }

  async handleEntityCreatedMultipleEvent(
    event: TranslateableEntityCreatedMultipleEvent,
  ) {
    const { entities, entityType, ctx } = event

    const createdTranslations = await Promise.all(
      entities.map(async (entity) => {
        const { id, ...fields } = entity
        return this.handleEntityCreatedEvent({
          entityId: id,
          entityType,
          fields,
          ctx,
        })
      }),
    )

    return createdTranslations
  }

  async handleEntityUpdatedMultipleEvent(
    event: TranslateableEntityUpdatedMultipleEvent,
  ) {
    const { entities, entityType, ctx } = event

    return await Promise.all(
      entities.map(async (entity) => {
        const { id, ...fields } = entity
        return this.handleEntityUpdatedEvent({
          entityId: id,
          entityType,
          fields,
          ctx,
        })
      }),
    )
  }

  async translateFields(
    ctx: RequestContext,
    fields: Record<string, string>,
    fromLang: string,
    toLang: string,
  ) {
    const translationProvider = await this.translateProviderFactory.getProvider(
      ctx,
      'GOOGLE_TRANSLATE',
    )

    const fieldsToTranslate = Object.entries(fields).filter((entry) =>
      Boolean(entry[1]),
    )

    if (fieldsToTranslate.length === 0) {
      this.logger.debug(`No fields to translate for entity`)
      return
    }

    const translated = await Promise.all(
      fieldsToTranslate.map(async ([key, value]) => [
        key,
        await translationProvider.translate(ctx, value, fromLang, toLang),
      ]),
    )

    return Object.fromEntries(translated)
  }

  private slugifySlugField(fields: Record<string, string>) {
    if (fields['slug'] && this.autoTranslateSlugify) {
      fields['slug'] = fields['slug'].replace(/\s+/g, '-')
    }
  }
}
